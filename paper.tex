\documentclass[useAMS,usenatbib]{mnras}

\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{cite}
\usepackage{natbib}
\usepackage{xcolor}
\usepackage{import}

\def\aap{Astronomy \& Astrophysics}
\def\apj{The Astrophysical Journal}
\def\mnras{Monthly Notices of the Royal Astronomical Society}
\def\aj{Astronomical Journal}
\def\aaps{AAPS}


\usepackage{newtxtext,newtxmath}
\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}
\usepackage{hyperref}

\newcommand{\red}[1]{{\color{red} #1}}
\newcommand{\degree}{^{\circ}}
%%%%%%%%%%%%%%%%%%% TITLE PAGE %%%%%%%%%%%%%%%%%%%


\title[SL Challenge]{The Strong Gravitational  Lens Finding Challenge}

\author[R. B. Metcalf {\it et al.}]{
R. Benton Metcalf,$^{1,4}$\thanks{E-mail: robertbenton.metcalf@unibo.it} 
M. Meneghetti,$^4$ 
Fabio Bellagamba,$^1$
Emmanuel Bertin,$^3$ 
\newauthor
R\'emi Cabanac,$^2$ 
Etienne Decenci\`ere,$^{10}$
Remi Flamary,$^8$
Mario Geiger,$^6$ 
\newauthor
Philippa Hartley,$^7$
Marc Huertas-Company,$^9$
Neal Jackson,$^7$ 
Jean-Paul Kneib,$^6$
\newauthor
Christoph Sch\"{a}fer,$^6$ 
Alessandro Sonnenfeld,$^5$ 
Amit Tagore,$^7$
Diego Tuccillo,$^{9,10}$
\newauthor
Santiago Velasco-Forero,$^{10}$
Camille Avestruz,$^{11,12,13,\dagger}$
Nan Li,$^{12,13,14}$
Matthew Lightman,$^{15}$
\newauthor
and ?\\
% List of institutions
$^{1}$ Departimento di Fisica \& Astronomia, Universit\`a di Bologna, via Gabetti 93/2, 4012 Bologna, Italy \\
$^{2}$ IRAP, University of Toulouse, CNRS, UPS, France.\\
$^{3}$ Sorbonne Universit\'{e}s, UPMC Univ. Paris 6 and CNRS, UMR 7095, Institut d'Astrophysique de Paris,  98bis Bd Arago, F-75014,\\ Paris France.\\
$^{4}$ INAF-Osservatorio Astronomico di Bologna, via Ranzani 1, 40127 Bologna, Italy \\
$^{5}$ Kavli IPMU (WPI), UTIAS, The University of Tokyo, Kashiwa, Chiba 277-8583, Japan\\
$^{6}$ \red{EPFL}\\
$^{7}$ Jodrell Bank Centre for Astrophysics, School of Physics \& Astronomy, University of Manchester, Oxford Rd, Manchester M13 9PL, UK \\
$^{8}$ Laboratoire Lagrange, Universi\'{e} de Nice Sophia-Antipolis, Centre National de la Recherche Scientifique, Observatoire de la C\^{o}te d'Azur, \\ Parc Valrose, 06108 Nice, France \\
$^{9}$ LERMA, Observatoire de Paris, CNRS, Universit\'e Paris Diderot, 61, Avenue de l'Observatoire F-75014, Paris, France \\
$^{10}$ Centre for mathematical morphology, Mathematics and Systems department, MINES ParisTech, 35 rue Saint-Honore, Fontainebleau, France \\
$^{11}${Enrico Fermi Institute, The University of Chicago, Chicago, IL 60637 U.S.A.}\\
$^{12}${Kavli Institute for Cosmological Physics, The University of Chicago, Chicago, IL 60637 U.S.A.}\\
$^{13}${Department of Astronomy \& Astrophysics, The University of Chicago, Chicago, IL 60637 U.S.A.}\\
$^{14}${High Energy Physics Division, Argonne National Laboratory, Lemont, IL 60439}\\
$^{15}${JPMorgan Chase, Chicago, IL 60603 U.S.A.}\\
$^\dagger${Provost's Postdoctoral Scholar at the University of Chicago}\\
}

\begin{document}

\date{Accepted . Received ; in original form }

\maketitle

\label{firstpage}

% Abstract of the paper
\begin{abstract}
We present a description and results of an open gravitational lens finding challenge.  Participants were asked to classify 100,000 candidate objects as to whether they were gravitational lenses or not with the goal of developing better automated methods for finding lenses in large data sets.   
\end{abstract}

\begin{keywords}
gravitational lensing -- cosmology 
\end{keywords}


\section{Introduction}
\label{sec:introduction}

Arcfinder\citep{2007A&A...472..341S}

\citet{2006astro.ph..6757A} arc finder used in the CFHT \citep{2007A&A...461..813C,2012ApJ...749...38M}

Some finders compare each image with a lens model \citep{2009ApJ...694..924M,2010A&A...517A..25S}.

\citep{2014A&A...566A..63J,2016A&A...592A..75P}

some numbers about future surveys

some background on past methods

The paper is organized as follows.  The form of the challenge and its rules are described in the next section.  The methods used to simulate mock images of galaxies and gravitational lenses are described in section~\ref{sec:simulation}.  In section~\ref{sec:entries} each of the methods that were used to solve the challenge are briefly described.  We discuss the metrics used to evaluate entries in section~\ref{sec:figure_of_merit}.  The performance of each of the methods broken down in different ways is presented in section~\ref{sec:performance}.  Finally,  in section~\ref{sec:conclusion}, we conclude with a discussion of what was learned and how methods can be improved in the future.

\section{The Challenge}
\label{sec:challenge}

The challenge was in fact two independent challenges that could be entered independently.  One was designed to mimic a single band of a future imaging data set from a satellite survey such as Euclid\footnote{https://www.euclid-ec.org/} \citep{***}.  The other was designed to mimic ground based data with multiple bands, roughly modeled on the Kilo-Degree Survey (KiDS)\footnote{http://kids.strw.leidenuniv.nl/} \citep{2013ExA....35...25D} .    In neither case were the simulated images meant to precisely mock these surveys, but only used them as general guide as to set noise levels, pixel sizes, sensitivities and other parameters.

In each case a training set of 20,000 images in each band was provided for download at any time along with a key giving some properties of the object including whether it was a gravitational lens.  Each image was $101\times101$ pixels.  The researchers were free to download these sets and train their algorithms on them.  To enter the contest the participants needed to register with a team name at which point they would be given a unique key and the address of a test data set.  These data sets contained 100,000 candidates.  In the case of the multi-band ground-based set this was 400,000 images. The participant had 48 hours to upload a classification of all candidates consisting of a score between 0 and 1 -- 0 signifying the lowest confidence that it is a lens and 1 signifying the highest confidence that it is a lens.  This ranking could have been a simple binary (0 or 1) classification  or it could have been a continuous range of numbers representing the probability of being a lens or it could have been a finite number of confidence levels.  

The challenge was opened on November 25, 2016 and closed on February 5, 2017.

\section{the simulations}
\label{sec:simulation}

Creating the mock images starts with a cosmological nbody simulation.  In this case it was the Millennium simulation \citep{2009MNRAS.398.1150B}.   A catalog of dark matter halos within a light-cone is constructed within the Millennium Observatory project \citep{2013MNRAS.428..778O} down to a mass of ****.   The challenge sets were based on a 1.6 sq.deg. light cone extending out to redshift 6.
The halo catalog is read into the GLAMER lensing code \citep{2014MNRAS.445.1942M,2014MNRAS.445.1954P} to do all the ray-tracing.  This code projects the halos onto lens planes, in this case 20, and finds the deflection angle on each plane by a hybrid tree method.  In this way the halos have the mass, concentration and clustering properties from the nbody simulation, but within each strong lens the mass resolution is not limited by the original simulation, but follows the analytic mass profile.  

With GLAMER we identify and map out all the caustics within the light-cone for 33 source planes -- z=1 to 3 in intervals of 0.1 and 3 to 6 in intervals of 0.25.  We take every caustic that corresponded to a critical curve with an Einstein radius larger than 1.5 times the resolution.  The Einstein radius is estimated here and in all that follows as $R_{\rm ein}=\sqrt{A_{\rm ein}/\pi}$ where $A_{\rm ein}$ is the angular area within the critical curve.

 A **** square degree light-cone gives rise to **** such caustics, but these over count the number of lenses since most will have caustics on multiple source planes.  These lenses could be used as is, but we want to produce a much larger number with more randomness.   For each caustic we identify the lens plane with the highest convergence and identify all the halos within a three dimensional distance of 0.5 Mpc from the center of the critical curve and on this and its neighboring lens planes.    This collection of halos is then used as the lens and rotated to produce more random lenses.    It  contains all the subhalos and near by companion halos, but not the large scale structure surrounding it.

For lensed sources we use sources from the Hubble Ultra Deep Field (UDF) that have been decomposed into shapelet functions to remove noise.  This is the same set of images as used 
in  \red{*** Massimo: Can you put a citation in for this?}.   There are 9,350 such sources with redshifts and separate coefficients in 10 bands.   

To construct a mock lens, first a caustic on the highest redshift source plane is selected.  This is done in order of Einstein area, but all the critical curves are used more than once.  Since every lens with a caustic at a lower redshift will have a caustic at the highest redshift this is a selection from all of the caustics in the light-cone.   The lens is extracted as explained above and rotated randomly in three dimensions.  A source is selected at random from the shapelet catalog subject to a magnitude limit in a target band.   The redshift of the UDF source is used as the source redshift.  If the source is at a lower redshift than the lens or within $\Delta z = 0.4$ another source is selected.

The furthest point in the caustic is found from its own center and the source is placed randomly within 3 times this distance.  This is a somewhat arbitrary length designed to be a compromise between producing only very clear strong lenses because all the sources are right in the center of the caustic and making the process  inefficiently because most of the sources are too far away from the caustic to produce clear lenses.  If the source positions where taken completely at random the fraction of clear lenses would be very low.

The visible galaxies associated with the lens must also be simulated.
There were not enough large galaxies in the UDF catalog to make enough mock lens galaxies for this purpose.  Instead, for most of the lenses, we used an analytic model for the surface brightness of these galaxies.  The Millennium Observatory provides parameters for the galaxies that inhabit the dark matter halos using the semi-analytic galaxy formation models of \citet{2011MNRAS.413..101G}.  The parameters used here were the total magnitude, the bulge-to-disk ratio, the disk scale height and the bulge effective radius.  The magnitude and bulge-to-disk ratio are a function of the pass band.  Each galaxy is given a random orientation and inclination angle.between 0 and $80\degree$.  The disk is exponential with no vertical height which is why the inclination is limited to $80\degree$.  The bulge is represented by a S\'{e}rsic profile with a axis ratio randomly sampled between 0.5 and 1.  The S\'{e}rsic index, $n_s$, is by 
\begin{align}
\log( n_s )= 0.4 \log\left[ {\rm max}\left(\frac{B}{T},0.03\right)\right] + 0.1 x 
\end{align}
where $\frac{B}{T}$ is the bulge to total flux ratio and $x$ is a uniform random number between -1 and 1.  This approximately reproduces the observed correlation between these quantities.

In addition to the basic disk and bulge models we introduce some spiral arms.  The surface brightness of 
the disks are given by
\begin{align}
S(\theta,r) = e^{-r/R_h} \left( 1 + A \cos(N_a\theta + \phi_r \right) ~, \\
\phi_r = \alpha\log(2 r/ R_h) + \phi_d \nonumber
\end{align}
where $R_h$ is the scale height of the disk.  The phase angle of the arms, $\phi_d$, is chosen at random.  The parameters $A$, $\alpha$ and $N_a$ are chosen from distributions that are judged by eye to produce realistic 
galaxies.
The bulge is also perturbed from a perfect S\'{e}rsic profile by multiplying the surface brightness by
\begin{align}
1+\sum_{n=1}^6 a_n \cos\left( n \theta  + \phi_n \right)
\end{align}
where $\phi_n$ is a random phase.  The coefficients are picked randomly from between -0.002 and 0.002.

These foreground galaxies are rotated in three dimensions with the halos of the lens each time a random lens is produced so that they remain in the same same positions relative to the mass.  All the random parameters are also reassigned with every realization of the lens.

These images of the of foreground galaxies are not intended to reproduce the true population of galaxies, but only to be sufficiently irregular to make them difficult to fit to a simple analytic model that might make them very easy to distinguish from a foreground plus a lensed image.   As will be discussed later, more realistic models will be needed in the future and are a subject of current investigation.

To represent the mass of the galaxies we make a gridded map of the surface brightness at 3 times the resolution of the final image.  The surface brightness map in converted into a mass map by assuming a uniform mass-to-light ratio of 1.5 solar in the target band.  This mass map is added to the lens before the ray tracing is done.

The code is able to produce any combination of foreground galaxies, lensed image and noise that is desired.  For the training set we provided an image of the total lens with noise, an image of the foreground galaxies with noise and and image of the lensed background source without noise.
For the test sets only the final images were provided to participants although all the information was stored for analyzing the entries.

\subsection{space-based}
\label{sec:sim-space-based}

For the space-based datasets the pixel size was set to 0.1 arcsec and 
a simple Gaussian PSF was applied with a FWHM of 0.18 arcsec.  
The reference band was SDSS K.  The noise is based on a 1,800 second exposure, a transmission of 0.3, a telescope diameter of 119~cm, a readout noise of 5 electrons per pixel and a sky background of 22.8 magnitudes per sq.arcsec.  
We use a simple Gaussian random realization of the noise uncorrelated between pixels.
 
 In the challenge set the limiting magnitude for background sources to 28 in K.   60\% of the cases had no background source and were thus labeled as non-lenses.
 
\subsection{ground-based}
\label{sec:sim-ground-based}

For the ground-based images four bands where I, G, U and R.  The reference band was R.  For the challenge set 85\% images where made with purely simulated images as outlines above and the other 15\% used actual images taken from a preliminary sample of bright galaxies directly from the KiDS survey.  Lensed source images where added to these real images at the same rate as for the mock images,  in this case 50\%.  No attempt was made to match the halo masses to the observed galaxies in these cases.  These real images where added for more realism and so that, by comparing the results for real and mock images, we can evaluate how realistic our simulations are in this context.  There were about number 160,000 of these stamps from KiDS.

The KiDS survey provided a representative PSF map in each band that was applied to all mock images.   The pixel size in this case was 0.2~arcsec. 
Weight maps for the KiDS images were also provided some of which have masked regions from remove stars, cosmic rays and bad pixels.  For the mock images the noise was simulated by adding normally distributed numbers with the variance given by the weight maps taken.  The weight maps where also randomly rotated and flipped.  This resulted in many of the images having large masked regions in them.

By chance one of the original KiDS images appears to have been a lens.  When an additional lensed source was added this made a double lens or "jackpot" lens.

\section{the entries}
\label{sec:entries}

There were 24 valid entries into the challenge.  They are listed in table~\ref{table:entries}.  There were a variety of different methods used and participants come from a variety of different backgrounds, most were professional astronomers, but there were also entries form people outside of the field.  

\begin{table*}
\centering
\begin{tabular}{rlll}
  \hline
 & Name & type & authors \\ 
  \hline
  1 & AstrOmatic & Space-Based & Bertin   \\ 
  2 & GAHEC IRAP & Space-Based & Cabanac  \\ 
  3 & CAS Swinburne Melb & Ground-Based & Jacobs   \\ 
  4 & ALL-star & Ground-Based & Avestruz, N.Li \& Lightman  \\ 
  5 & Manchester1 & Space-Based & Jackson, Hartley \& Tagore  \\ 
  6 & CMU-DeepLens-Resnet-Voting & Space-Based & Ma, Lanusse \& C. Li  \\ 
  7 & Manchester SVM & Ground-Based & Hartley   \\ 
  8 & CMU-DeepLens-ResNet & Space-Based & Francois Lanusse, Ma, C. Li \& Ravanbakhsh \\ 
  9 & CMU-DeepLens-Resnet-Voting & Ground-Based & Ma, Lanusse \& C. Li   \\ 
  10 & YattaLensLite & Space-Based &  Sonnenfeld  \\ 
  11 & NeuralNet2 & Space-Based &  Davies  \\ 
  12 & CAST & Ground-Based &  Roque De Bom, Valent\"{\i}n \&  Makler  \\ 
  13 & CMU-DeepLens-ResNet-ground3 & Ground-Based &  Lanusse, Ma, Ravanbakhsh \& C. Li \\ 
  14 & GAMOCLASS & Space-Based & Marc Huertas-Company, Tuccillo, Velasco-Forero \& Decenci\~{a}re \\ 
  15 & LASTRO EPFL (CNN) & Space-Based & Geiger, Sch\"{a}fer \& Kneib \\ 
  16 & Manchester SVM & Space-Based &  Hartley  \\ 
  17 & CMU-DeepLens-ResNet-aug & Space-Based & Ma,  Lanusse, Ravanbakhsh \& C. Li \\ 
  18 & LASTRO EPFL & Ground-Based & Geiger, Sch\"{a}fer \& Kneib   \\ 
  19 & CAST & Space-Based & Roque De Bom, Valent\"{\i}n \& Makler  \\ 
  20 & AstrOmatic & Ground-Based & Bertin  \\ 
  21 & All-now & Space-Based & Avestruz, N. Li \& Lightman   \\ 
  22 & Manchester-NA2 & Ground-Based & Jackson \& Tagore  \\ 
  23 & YattaLensLite & Ground-Based & Sonnenfeld   \\ 
  24 & Kapteyn & Space-Based & Petrillo, Koopmans, Kleijn, Tortora \& Vernardos \\ 
   \hline
\end{tabular}
\caption{Entries to the challenges.}
\label{table:entries}
\end{table*}

\section{lens finding methods}
\label{sec:methods}

This section contains short descriptions of the lens finding methods that were used in 
the challenge.  Each subsection refers to a team which gave a separate entry.

\subsection{GAHEC IRAP (Cabanac)}

\begin{figure}
 \includegraphics[width=\columnwidth]{figures/arcmethod.pdf}
 \caption{ (GAHEC IRAP) From top-left to bottom right, 1) a simulated arc extracted from SL challenge in which an tuned Arcfinder selects 3 candidates (green circles), 2) the smoothed image on which pixel wise elongation is computed, 3) the resulting elongated pixels after threshold, 4) the set of pixels selected for the computation of arc candidate properties. }
 \label{fig:Cabanac}
\end{figure}

Arcfinder \citep{astronaut.ph..6757A,2007A&A...461..813C,2012ApJ...749...38M} is a fast linear method that computes a pixel wise elongation parameter (ratio of first-order moments in a n-pix window oriented in proper reference frame) for all pixels of mexican-hat-smoothed FITS images. Arcfinder then extract contiguous pixels above a given background and computes the candidate arcs length, width, area, radius of curvature and peak surface brightness. A final thresholding is set to maximize purity over completeness on a few typical arcs of the dataset.
For the current SL challenge, arcfinder was tuned to detect long and narrow arcs, and was optimized on a subset of 1000 simulated images with a grid covering a range of elongation windows and arc areas.  A python wrapper allows users to change parameters in a flexible way and run the arcfinder C code as a linux line command. Arcfinder took a couple of hours to run on the entire dataset with some overheads due to the dataset format. The code is publicly available at https://github.com/rcabanac/arcfinder.

\red{Reference to figure \ref{fig:Cabanac}?}

\subsection{AstrOmatic (Bertin)}

The lens detector is based on a convolutional neural network (CNN), trained with the provided training datasets. The CNN is implemented in Python, using the TensorFlow framework\footnote{http://www.tensorflow.org/}. Both ground multichannel and space monochannel image classifiers have the exact same CNN architecture.

The network itself consists of three convolutional layers ($11\times 11\times 32$, $5\times 5 \times 64$ and $3\times 3\times 64$), followed by two fully-connected layers ($256$ and $64$ neurons) and an output softmax layer. The first five layers use the ELU (Exponential Linear Unit) activation function \citep{2015arXiv151107289C}, which in our tests led to significantly faster convergence compared to ReLU and even SoftPlus activation. Dropout regularization \citep{2012arXiv1207.0580H,JMLR:v15:srivastava14a} is applied to both convolutional and fully connected layers, with ``keep'' probabilities $p=2/3$ and $p=1/2$, respectively.

Prior to entering the first convolutional layer, input image data are rescaled and dynamic-range compressed with function $f(x) =
\mathrm{arcsinh} (10^{11} x)$, and bad pixels are simply set to 0.
Data augmentation is performed in the form of random up-down and left-right image flipping, plus $k\pi/2$ rotations, where $k$ is a random integer in the $[0,3]$ range. Additionally, a small rotation with random angle $\theta$ is applied, involving bicubic image resampling. $\theta$ follows a Gaussian distribution with mean $\mu=0$ and standard deviation $\sigma_{\theta}=5^{\circ}$. No attempt was made to generate and randomize bad pixel masks in the data augmentation process.

The CNN weights are initialized to random values using a truncated Gaussian distribution with mean $\mu=0$ and standard deviation $\sigma=5.10^{-2}$. The network is trained on a Titan-X ``Pascal'' nVidia GPU using the Adam gradient-based optimizer \citep{2014arXiv1412.6980K} during 800 epochs, with an initial learning rate $\eta(t=0)=10^{-3}$ and a learning rate decay $\eta(t+1)/\eta(t)=0.99$, where $t$ is the epoch. Because of a lack of time, tests were limited to assessing the basic classification performance on a subset of the of 1,000 images/datacubes, using the 19,000 others for training.

\subsection{YattaLens Lite (Sonnenfeld)}
YattaLensLite is a simpler version of the algorithm YattaLens \citep{Sonnenfeld17}, modified to meet the time constraints of the challenge.
YattaLensLite subtracts a model surface brightness profile describing the lens galaxy from the $g$-band image, then runs SExtractor to detect tangentially elongated or ring-shaped objects, which are interpreted as lensed images.
In the ground-based challenge, the model lens surface brightness profile is obtained by taking a rescaled version of the $i$-band image.
The difference in color between lens and source usually allows the lensed images to still be detectable after the lens subtraction process.
However in order to avoid subtracting off the lensed images in systems with similar colors between lens source, we radially truncate the model lens surface brightness.
at the smallest radius between the position where the surface brightness is comparable to the sky background level or the position of a positive radial gradient in surface brightness, if detected.

In the space-based challenge it is not possible to separate lens and source based on color, because only data in one band is provided. The lens light model then is produced by taking a centrally-inverted image and then using the same truncation prescription used with ground-based data. The central inversion step is taken to reduce the chances of subtracting flux from lensed images, which are in general not centrally symmetric as opposed to typical lens galaxies.

In the full version of YattaLens, a lens modeling step is performed to improve the purity of the sample. However, such a procedure is too time consuming and was not performed in this challenge.


\subsection{LASTRO EPFL (Geiger, Sch\"{a}fer)}

We used a convolutional neural network \citep{Fukushima1980,Lecun1998} with a simple architecture of 12 layers (inspired by \citep{symmetry}), see table \ref{tab:architecture}.
To avoid the problem of the data flow distribution getting out of the comfort zone of the activation functions (Internal Covariate Shift), we used a mix of normalization propagation \citep{norm_prop} (without the constraint on the weights but a proper initialization) and batch normalization \citep{batch_norm} (slowly disabled over the iterations).
As activation function, we used a scaled and shifted ReLU (Rectifier Linear Unit), 
\begin{equation} \label{eq:relu}
    \frac{1}{\sqrt{\pi-1}} (\sqrt{2 \pi} \max(0,x) - 1),
\end{equation}
to satisfy the properties required by the normalization propagation.
In our implementation of batch normalization, instead of using only the moments computed over the current batch, we used a low-pass filter ($\bar\mu_i \longleftarrow (1-\eta) \; \bar\mu_{i-1} + \eta \; \mu_i(\text{batch})$, $\eta$ set to $1$ at the beginning and decay with the iterations).
For the training, the 20k provided images were split into two sets, 17k for training and 3k for validation.
Each iteration of the gradient descent (more precisely ADAM \citep{adam}) minimizes the cross entropy, 
\begin{equation} \label{eq:xent}
    \left\{
    \begin{array}{ll}
        - \log(p)   & \text{if the image is a true lens} \\
        - \log(1-p) & \text{if the image is a nonlens}
    \end{array}
    \right.,
\end{equation}
where $p$ is the output of the neural network, computed over a batch of 30 images, 15 lenses and 15 nonlenses, picked from the training set.
Making batches of 30 images adds noise to the gradient makes the iterations faster.

To augment the training set, each image of the batch is transformed with a random transformation of the dihedral group (rotations of 90 degrees and mirrors), its pixel values multiplied by a factor picked between $0.8$ and $1.2$ and shifted by a random value between $-0.1$ and $0.1$.
To prevent the overfitting, we used some dropout \citep{dropout} (with a keeping probability decreasing with the iterations).
The masked region of the ground based images are handled by simply setting them to zero.
Each final prediction is made of the product of the predictions of the 8 transformations of the image by the dihedral group.
The architecture is implemented in Tensorflow\footnote{\url{http://tensorflow.org/}}.
Our code is accessible on github\footnote{\url{https://github.com/antigol/lensfinder-euclid}}.

\begin{table*}
    \centering
    \begin{tabular}{|l|l|l|l|}
        \hline
        Layer type & shape & activation & \# parameters \\ \hline \hline
        
        \textbf{convolutional 4x4} & $101\!\times\! 101\!\times\!1/4 \to 98\!\times\!98\!\times\!16$ & rectifier & 256/1'024 + 16 \\ \hline
        \textbf{convolutional 3x3} & $98\times98\times16 \to 96\times96\times16$ & rectifier & 2'304 + 16 \\ \hline
        max pool /2 & $96\times96\times16 \to 48\times48\times16$ & - & - \\ \hline
        batch normalization & $48\times48\times16$ & - & 16 + 16 \\ \hline
        
        \textbf{convolutional 3x3} & $48\times48\times16 \to 46\times46\times32$ & rectifier & 4'608 + 32 \\ \hline
        \textbf{convolutional 3x3} & $46\times46\times32 \to 44\times44\times32$ & rectifier & 9'216 + 32 \\ \hline
        max pool /2 & $44\times44\times32 \to 22\times22\times32$ & - & - \\ \hline
        batch normalization & $22\times22\times32$ & - & 32 + 32 \\ \hline
        
        \textbf{convolutional 3x3} & $22\times22\times32 \to 20\times20\times64$ & rectifier & 18'432 + 64 \\ \hline
        \textbf{convolutional 3x3} & $20\times20\times64 \to 18\times18\times64$ & rectifier & 36'864 + 64 \\ \hline
        max pool /2 & $18\times18\times64 \to 9\times9\times64$ & - & - \\ \hline
        batch normalization & $9\times9\times64$ & - & 64 + 64 \\ \hline
        dropout & $9\times9\times64$ & - & - \\ \hline
        
        \textbf{convolutional 3x3} & $9\times9\times64 \to 7\times7\times128$ & rectifier & 73'728 + 128 \\ \hline
        dropout & $7\times7\times128$ & - & - \\ \hline
        \textbf{convolutional 3x3} & $7\times7\times128 \to 5\times5\times128$ & rectifier & 147'456 + 128 \\ \hline
        batch normalization & $5\times5\times128$ & - & 128 + 128 \\ \hline
        dropout & $5\times5\times128$ & - & - \\ \hline
        
        \textbf{fully-connected} & $5\times5\times128 \to 1024$ & rectifier & 3'276'800 + 1'024 \\ \hline
        dropout & $1024$ & - & - \\ \hline
        \textbf{fully-connected} & $1024 \to 1024$ & rectifier & 1'048'576 + 1'024 \\ \hline
        dropout & $1024$ & - & - \\ \hline
        \textbf{fully-connected} & $1024 \to 1024$ & rectifier & 1'048'576 + 1'024 \\ \hline
        batch normalization & $1024$ & - & 1'024 + 1'024 \\ \hline
        \textbf{fully-connected} & $1024 \to 1$ & sigmoid & 1'024 + 1 \\ \hline \hline
        Total & - & - & $\approx$ 5'674'000 \\ \hline
    \end{tabular}
    \caption{LASTRO EPFL architecture}
    \label{tab:architecture}
\end{table*}

\subsection{Manchester/Manchester1 (Jackson,Tagore)}

All images (a total of 100000) were examined for each of the space- and
ground-based datasets. This was done by two observers; AT examined 30000
images in each case and NJ examined 70000. Observation was carried out
over a 48-hour period, at the rate of 5000/hr (NJ) and 2500/hr (AT). 
The overall results, in terms of ROC curves, were very similar for 
both observers. The space-based challenge produced areas of 0.800 and 
0.812 for NJ and AT respectively, and the ground-based challenge yielded 
0.891 and 0.884.

The Python scripts used for manual examination of multiple images are available
on https://github.com/nealjackson/bigeye and are described in more detail
in Hartley et al. (2016, in preparation). For one-colour data such as
the space-based training set, the images are individually colour-scaled using
square-root scaling. The bright limit of the colour-scale is determined
from the pixel values in a rectangle comprising the inner ninth of the
image area, with the limit being chosen as the $n$th centile of the pixel
values in this area. Values between $n=95$ and $n=98$ give optimum results,
judging by experiments on the training set. The number of images in each
grid was also optimised using the training set, with 16$\times$8 or 
8$\times$4 giving good results on one-colour data. For three-colour data,
such as the ground-based challenge data, the individual bands for each 
object are colour-scaled and then combined into an RGB image. In this case
8$\times$4 grids were used for examination, due to the generally lower 
resolution of the images. The script also allows the user to adjust the
colour-scale in real time when examining and marking images, and records
the image name corresponding to the image within which the cursor resides
at the time any key is pressed, together with the key.

Images were classified by both observers into 5 categories, ranging from
0 (no evidence of any lensed objects in the image) to 4 (certain lenses).
For both observers, the rate of false positives in the ``certain'' lenses
was between 0.1\% and 0.3\%. The exception was the ground-based imaging 
for one observer, where a 4.6\% rate resulted mainly from a
single decision to allow a false-positive ``double lens'' which occurred
repeatedly throughout the data at different orientations. The false-negative
rate among the class-0 identifications was similar for both observers, at
around 25\% for the space-based images and 20\% for the ground-based.

\subsection{Gabor-SVM (Hartley,Flamary)}

A Support Vector Machine (SVM) is a supervised machine learning method which uses labeled training data to determine a classification model (see e.g., \citet{vapnik79estimation}, \citet{Cortes1995} and \citet{Burges1998}). A preprocessing stage first extracts a set of useful features from input samples, before projecting each sample as a vector in multidimensional space. The model then separates classes of data by maximising the margin between a defining hyperplane and a set of so-called support-vectors at the inner edge of each class. The process of classification is computationally inexpensive since optimisation depends only on the dot products of the support vector subset. Feature extraction, however,  requires both an extensive exploration of the feature space during the development of a model, and potentially intensive computer resources in order to transform the original samples. Our full method is described in detail in Hartley et. al., in prep., and was developed using the Python scikit-learn and scikit-image packages \citep{scikit-learn,scikit-image}.

During our development of an SVM classifier for lens finding, feature extraction initially involved the decomposition of each image into a set of objects, using SExtractor \citep{1996A&AS..117..393B} and GALFIT \citep{2002AJ....124..266P} to recover and subtract objects iteratively. This method had previously been used in a static algorithm approach which assigned points according to the morphological properties of each image \citep[see][]{2014A&A...566A..63J}. Lensed-like objects displaying, for example, greater ellipticity and tangentiality were awarded more points. Since the SVM operates in a fixed dimensional space,  properties of individual objects were collapsed into a fixed set describing the mean and variance of morphological properties of all the objects within an image. After training an SVM using these features we recorded a modest separation of lens and non-lens classes.

An alternative approach was to design a set of Gabor filters to be applied to each sample. The Gabor kernel is described by a sinusoidal function multiplied by a Gaussian envelope. We discard the imaginary part of the function to leave, in two-dimensional space:

\begin{equation}
G_c[i,j]=Be^{-\frac{(i^2+j^2)}{2\sigma^2}} \mathrm{cos}\left(\frac{2\pi}{\lambda} (i\, \mathrm{cos} \, \theta + j\, \mathrm{sin} \,\theta)\right),
\end{equation}

where harmonic wavelength $\lambda$, Gaussian spread  $\sigma$ and orientation $\theta$ define the operation performed on each point $i,j$ in an image. Such a kernel is a popular image processing choice for edge detection and texture classification \citep[e.g.][]{Feichtinger98a,Springer-verlag97computationalmodels} and is thought to mimic some image processing functions of the mammalian brain \citep{Jones1233}.


\begin{figure}
  \centering
      \includegraphics[width=1\columnwidth]{figures/polarfilter.pdf} 
  \caption{Example of our feature extraction procedure used to transform a ring. The image on the right shows the response of a set of Gabor filters after convolution with a polar transformed image of an Einstein ring. The strongest response is seen in the orientation perpendicular to the radial direction and at the frequency most closely matching that of the ring.}
 \label{gaborring}
\end{figure}

Our final feature extraction procedure first applied a polar transform to each image in order to exploit the edge detection of the Gabor filter, picking out tangential components typical of galaxy-galaxy lensing. Each image was then convolved with several Gabor filters of varying frequency and rotation (see Fig.~\ref{gaborring}). Stability selection methods were used to investigate the classification performance using different combinations of filters. The responses for each Gabor filter when applied to each image were measured by calculating statistical moments for each filtered image. These moments formed  our final input data on which the SVM could be trained and applied. We used brute-force optimisation methods to select a non-linear SVM containing radial basis function (RBF) kernel and tuned a small set of regularisation hyperparameters to achieve good generalisation performance. During training and testing, our final and best scores achieved when testing on the lens finding challenge training data were an AUC of 0.88 for the space set and 0.95 for the ground set. Classification was performed using a modest desktop PC.

\subsection{GAMOCLASS (Tuccillo, Huertas-Company, Velasco-Forero, Decenci\`ere)}

\begin{figure}
  \centering
      \includegraphics[width=1\columnwidth]{figures/Fig1_gamoclass.pdf} 
  \caption{GAMOCLASS schematic}
 \label{Fig1_gamoclass}
\end{figure}

Our algorithm for classification of strong lensed galaxies was developed as a convolutional neural network (CNN) used for binary classification task.
Our code was trained and tested on the space-based dataset (dataset 0) provided for the Strong lensing challenge, comprising 20,000 stamps of single band simulated galaxies. We used the full dataset in the proportion of 4/5 for training and 1/5 for validation. The training images were labelled with 1 if showing strong lensing and 0 otherwise. Our CNN gives as output a probability [0,1] of the input image being a strongly lensed system.
The final architecture of our model is illustrated in Fig. \ref{Fig1_gamoclass}. The input image (101x101 pixels) is first processed by a 2D convolution layer with a 3x3 filter size, then subsampled by a 3x3 max pooling layer. Other two identical units follow, with a growing dimensionality of the output space (depth, i.e.output number of filters) in the convolution, for a total of 3 convolutional layers and 3 max pooling layers. Each of these convolutional layers is followed by a rectified linear unit (ReLU) step. The output of these units is then processed through a single fully-connected layer follower by a dropout layer, and, finally, by a one-neuron fully connected layer with sigmoid activation function. For the classification problem we used the binary cross-entropy cost function and for weights updates we used an adaptive moment estimation (ADAM, \citealt{Kingma_2014}) optimization method. The use of the ADAM optimizer improves the learning rate, and previous tests with stochastic gradient descent (SGD) lead to worse results on the classification of the validation sample.
In order to increase the size of the training set and make the model invariant to specific transformations, we perform several data augmentation steps:
\begin{itemize}
\item Random rotation of the image in the range [0, 180$\degree$], using a reflection fill mode to keep constant the size of the images.
\item The images were randomly shifted of 0.02 times the total width of the image.
\item Random horizontal and vertical flips of the images
\end{itemize}
During the training we initialize the weights of our model with random normal values and we warm up the training \citet{Huang_2016} of the CNN for 25 epochs, using an exponential decay rate (1e-6) and a staring learning rate of Î± = 0.001. Then the network is trained using an early stopping method, and for a maximum number of 300 epochs. The early stopping method is an effective method to prevent overfitting and consists in stopping the training if a monitored quantity does not improve for a fixed number (called \textit{patience}) of training epochs. The quantity that we monitored was the \textit{accuracy} of the classification of the validation sample. The best architecture was trained over 220 epochs with a parameter of patience equal to 20.
We implemented our code the Keras framework \citet{Chollet_2015} on top of Theano \citet{Bastien_2012}.
Our architecture converges with a classification accuracy of 91\% on the validation sample. We further evaluated the performance of our classifier calculating the ROC curve of the classifier, i.e. the True Positive Rate (TPR) against the False Positive Rate. As shown in Fig. \ref{Fig2_gamoclass}, we reach a TPR higher than the 90\% with a FPR < 8\%.

\begin{figure}
  \centering
      \includegraphics[width=1\columnwidth]{figures/Fig2_gamoclass.pdf} 
  \caption{GAMOCLASS ROC on training data.}
 \label{Fig2_gamoclass}
\end{figure}

%-------------------------------------------------%
\subsection{ALL Methodology (Avestruz, Li, Lightman}
%-------------------------------------------------%

We detail the ALL team methodology in \citet{avestruz_etal17}. The
pipeline was originally developed to automatically classify strong
lenses in mock Hubble Space Telescope and Large Synoptic Sky Telescope
data generated with code described in \citet{li_etal16} and
\citet{collett_15}.  We apply the same exact steps for the single-band
data for Euclid, but modify the feature extraction step for the
four-band KIDS data.  We summarize the steps below.

We use tools from {\em Scikit-learn} \citep{pedregosa_etal12} and
perform minimal image preprocessing. First, we replace masked pixels
with the average of surrounding pixels, then enhance contrast in the
image by taking the normalized log of pixel values.  The next step of
our pipeline consists of a feature extraction stage, where our feature
vector is a {\em histogram of oriented gradients} (HOG)
\citep{dalalandtriggs_05} that quantifies edges in the image.  HOG has
three main parameters that determine the binning and resolution of
edges captured by the features.  The result is a one dimensional
feature vector corresponding to the magnitude of oriented gradients
across the image.  With the KIDS data, we extract a feature vector for
each of the four bands and concatenate the vectors to create a final
feature vector for each object that we use to train a model
classifier.

We use {\em Logistic Regression} (LR), a machine learning algorithm,
to train a classifier model.  LR requires a parameter search over the
regression coefficient, $C_{LogReg}$.  The parameters from both the
feature extrator, HOG, and the linear classifier, LR, contain
parameters that we optimize for peak model performance.  We use {\em
  GridSearchCV} from {\em Scikit-learn} to select cross-validated
parameters for HOG parameters and a subset of $C_{LogReg}$ values with
20\% of the test images provided.  We then run a finer parameter
search over $C_{LogReg}$, splitting the test images into 80\% training
and and 20\% test to avoid overfitting the data.  We use the best
parameters to then train the entire dataset for the final model
classifier that we used to evaluate the competition data.

\section{results}
\label{sec:results}

In this section we summarize some of our analysis of the submissions.  In section~\ref{sec:figure_of_merit} we discuss how to judge a classifier in this particular case and define some metrics of success.

\subsection{figures of merit}
\label{sec:figure_of_merit}

In deriving a good figure of merit for evaluating lens finding algorithms one needs to take into account the particular nature of this problem.
The traditional method for evaluating a classification algorithm is with the receiver operating characteristic curve, or {\bf ROC} curve.  This a plot of the true positive rate (TPR) and the false positive rate (FPR).  In this case these are defined as
\begin{align}
{\rm TPR} &= \frac{\textrm{ number of true lenses classified as lenses}}{\textrm{ total number of true lenses}} \\
{\rm FPR} &= \frac{\textrm{number of non-lenses classified as lenses}}{\textrm{ total number of non-lenses}}
\end{align}
The classifier generally gives a probability of a case being a lens, $p$ in which case a threshold is set and everything with $p$ greater is classified as a lens and everything smaller classified as not a lens.  The TPR and FPR are then plotted as a curve parametrised by this threshold.  At $p=1$ all of the cases are classified as non-lenses and so TPR=FPR=1 and at $p=0$ all of the cases are classified as lenses so TPR=FPR=0.  These points are always added to the ROC curve.  If the classifier made random guesses then the ratio of lenses to non-lenses would be the same as the ratio of the number of cases classified as lens to the number of cases classified as non-lenses and so TPR=FPR.  The better a classifier is the smaller the FPR and the larger the TPR so the further away from this diagonal line it will be.  When a classifier provides only a binary classification or a discrete ranking the ROC connects the endpoints to the discrete points found be using each rank as a threshold.

A common figure of merit for a classifier is the area under the ROC ({\bf AUROC}).  This evaluates the overall ability of a classifier to distinguish between cases.  This was the criterion on which the challenge participants were told to optimize.  However, in the case of gravitational lensing this is not the only thing, and not the most important thing, to consider.  Gravitational lenses are rare events, but to improve the discrimination and training of the classifies the fraction lenses in the boosted to something around half.  In these circumstances it is important to consider the absolute number of cases that will be missclassified when the fraction of true cases is closer to what is expected in the data.

If the rates of false positives and false negatives remain the same in real data  the contamination of the sample will be
\begin{align}
\frac{\rm FP}{\rm TP} \simeq \frac{\rm FPR}{\rm TPR} \left(\frac{\textrm{number of non-lenses in sample}}{\textrm{number of lenses is sample}} \right)
\end{align}
Since only about one in a thousand objects will be lenses (perhaps somewhat more depending on pre-selection) the contamination will be high unless the FPR is much less than the TPR.  For this reason we consider some additional figures of merit.

The {\bf TPR$_0$} will be defined as the highest TPR reached, as a function of $p$ threshold, before a single false positive occurs in the test set of 100,000 images.  This is the point were the ROC meets the FPR = 0 axis.  This quantity highly penalizes classifiers with discrete ranking which often get TPR$_0$ = 0 because their highest classification level is not conservative enough to eliminate all false positives.  We also define {\bf TPR$_{10}$} which is the TPR at the point were less than ten false positives are made.  If the TP 
rate is boosted from the FPR by a factor of 1,000 in a realistic dataset with would correspond to about a 10\% contamination.

In addition to these considerations, the performance of a classifier is a function of many characteristics of the lens system.  It might be that one classifier is good at finding systems with large Einstein radii and incomplete arcs, but not as good at finding small complete Einstein rings that are blended with the light of the lens galaxy.  Also lens may have a source that is too faint to be detected by any algorithm or is too far from the lens to be very distorted, but will be classified as a lens in the test dataset.   We want to include these objects because we want to test the limits of the classifiers.  As we will see, if you restrict your objectives to detecting only lensed images with surface brightness above threshold, for example, the "best" algorithm might change and the TPR will change.  For this reason we plot the AUROC, TPR$_0$ and TPR$_{10}$ as a function of several variables for all the entries.  This is done by removing all the lenses that do not exceed the threshold and then recalculating the these quantities, the number of non-lenses remains the same.

\subsection{Performance of methods}
\label{sec:performance}

\begin{table*}
\centering
\begin{tabular}{llrrrl}
  \hline
  Name & type & AUROC & TPR$_0$ & TPR$_{10}$ & short description \\ 
  \hline
 CMU-DeepLens-ResNet-ground3 & Ground-Based & 0.98 & 0.09 & 0.45 & CNN \\ 
  CMU-DeepLens-Resnet-Voting & Ground-Based & 0.98 & 0.02 & 0.10 & CNN \\ 
  LASTRO EPFL & Ground-Based & 0.97 & 0.07 & 0.11 & CNN \\ 
  CAS Swinburne Melb & Ground-Based & 0.96 & 0.02 & 0.08 & CNN \\ 
  AstrOmatic & Ground-Based & 0.96 & 0.00 & 0.01 & CNN \\ 
  Manchester SVM & Ground-Based & 0.93 & 0.22 & 0.35 & SVM / Gabor \\ 
  Manchester-NA2 & Ground-Based & 0.89 & 0.00 & 0.01 & Human Inspection \\ 
   ALL-star & Ground-Based & 0.84 & 0.01 & 0.02 & edges/gradiants and Logistic Reg. \\ 
   CAST & Ground-Based & 0.83 & 0.00 & 0.00 & CNN / SVM \\ 
   YattaLensLite & Ground-Based & 0.82 & 0.00 & 0.00 & SExtractor \\ 
   LASTRO EPFL & Space-Based & 0.93 & 0.00 & 0.08 & CNN \\ 
  CMU-DeepLens-ResNet & Space-Based & 0.92 & 0.22 & 0.29 & CNN \\ 
   GAMOCLASS & Space-Based & 0.92 & 0.07 & 0.36 & CNN \\ 
  CMU-DeepLens-Resnet-Voting & Space-Based & 0.91 & 0.00 & 0.01 & CNN \\ 
  AstrOmatic & Space-Based & 0.91 & 0.00 & 0.01 & CNN \\ 
   CMU-DeepLens-ResNet-aug & Space-Based & 0.91 & 0.00 & 0.00 & CNN \\ 
   Kapteyn & Space-Based & 0.82 & 0.00 & 0.00 & CNN \\ 
   CAST & Space-Based & 0.81 & 0.07 & 0.12 & CNN \\ 
  Manchester1 & Space-Based & 0.81 & 0.01 & 0.17 & Human Inspection \\ 
   Manchester SVM & Space-Based & 0.81 & 0.03 & 0.08 & SVM / Gabor \\ 
   NeuralNet2 & Space-Based & 0.76 & 0.00 & 0.00 & CNN / wavelets \\ 
   YattaLensLite & Space-Based & 0.76 & 0.00 & 0.00 & Arcs / SExtractor \\ 
   All-now & Space-Based & 0.73 & 0.05 & 0.07 & edges/gradiants and Logistic Reg. \\ 
  GAHEC IRAP & Space-Based & 0.66 & 0.00 & 0.01 & arc finder \\ 
   \hline
\end{tabular}
\caption{The AUROC, TPR$_0$ and TPR$_{10}$ for the entries in order of AUROC.}
\label{table:AUROC}
\end{table*}

Table~\ref{table:AUROC} shows the AUROC, TPR$_0$ and TPR$_{10}$ for the entries in order of AUROC and dataset type.  It can be seen that CMU-DeepLens-ResNet-ground3 had the best AUROC for the ground-based set and LASTRO EPFL the best for the space-based set.  The order is different if TPR$_0$ is used to rank the entries as seen in table~\ref{table:TPR0}.  Here Manchester SVM and 
CMU-DeepLens-ResNet get the best scores.

\begin{table*}
\centering
\begin{tabular}{llrrrl}
  \hline
  Name & type & AUROC & TPR$_0$ & TPR$_{10}$ & short description \\ 
  \hline
 Manchester SVM & Ground-Based & 0.93 & 0.22 & 0.35 & SVM / Gabor \\ 
  CMU-DeepLens-ResNet-ground3 & Ground-Based & 0.98 & 0.09 & 0.45 & CNN \\ 
  LASTRO EPFL & Ground-Based & 0.97 & 0.07 & 0.11 & CNN \\ 
   CMU-DeepLens-Resnet-Voting & Ground-Based & 0.98 & 0.02 & 0.10 & CNN \\ 
   CAS Swinburne Melb & Ground-Based & 0.96 & 0.02 & 0.08 & CNN \\ 
   ALL-star & Ground-Based & 0.84 & 0.01 & 0.02 & edges/gradiants and Logistic Reg. \\ 
   Manchester-NA2 & Ground-Based & 0.89 & 0.00 & 0.01 & Human Inspection \\ 
   YattaLensLite & Ground-Based & 0.82 & 0.00 & 0.00 & SExtractor \\ 
   CAST & Ground-Based & 0.83 & 0.00 & 0.00 & CNN / SVM \\ 
   AstrOmatic & Ground-Based & 0.96 & 0.00 & 0.01 & CNN \\ 
   CMU-DeepLens-ResNet & Space-Based & 0.92 & 0.22 & 0.29 & CNN \\ 
   GAMOCLASS & Space-Based & 0.92 & 0.07 & 0.36 & CNN \\ 
   CAST & Space-Based & 0.81 & 0.07 & 0.12 & CNN \\ 
   All-now & Space-Based & 0.73 & 0.05 & 0.07 & edges/gradiants and Logistic Reg. \\ 
   Manchester SVM & Space-Based & 0.80 & 0.03 & 0.07 & SVM / Gabor \\ 
   Manchester1 & Space-Based & 0.81 & 0.01 & 0.17 & Human Inspection \\ 
   LASTRO EPFL & Space-Based & 0.93 & 0.00 & 0.08 & CNN \\ 
   GAHEC IRAP & Space-Based & 0.66 & 0.00 & 0.01 & arc finder \\ 
   AstrOmatic & Space-Based & 0.91 & 0.00 & 0.01 & CNN \\ 
   Kapteyn & Space-Based & 0.82 & 0.00 & 0.00 & CNN \\ 
   CMU-DeepLens-ResNet-aug & Space-Based & 0.91 & 0.00 & 0.00 & CNN \\ 
   CMU-DeepLens-Resnet-Voting & Space-Based & 0.91 & 0.00 & 0.01 & CNN \\ 
   NeuralNet2 & Space-Based & 0.76 & 0.00 & 0.00 & CNN / wavelets \\ 
   YattaLensLite & Space-Based & 0.76 & 0.00 & 0.00 & Arcs / SExtractor \\ 
   \hline
\end{tabular}
\caption{The AUROC, TPR$_0$ and TPR$_{10}$ for the entries in order of TPR$_0$.  }
\label{table:TPR0}
\end{table*}

\begin{figure*}
 \includegraphics[width=2\columnwidth]{figures/roc_space.pdf}
 \caption{The ROC curves for the space-based entries.}
 \label{fig:roc_space}
\end{figure*}

\begin{figure*}
 \includegraphics[width=2\columnwidth]{figures/roc_ground.pdf}
 \caption{The ROC curves for the ground-based entries.  Notice that these are are generally better than in figure~\ref{fig:einstein_space} indicating that colour information is an important discriminant. }
 \label{fig:roc_ground}
\end{figure*}

\begin{figure*}
 \includegraphics[width=2\columnwidth]{figures/roc_kids.pdf}
 \caption{The ROC curves for the ground-based entries including only the cases with authentic images taken from the KiDS survey.  It can be seen that in all cases these are lower than in figure~\ref{fig:roc_ground}.}
 \label{fig:roc_kids}
\end{figure*}

Figures~\ref{fig:roc_space} and \ref{fig:roc_space} show the ROC curves for all the entries.  In addition figure~\ref{fig:roc_kids} shows the ROC curves for only the ground-based images where an actual KiDS image was used (see section~\ref{sec:sim-ground-based}).  It can be seen that the classifiers do uniformly less well on this subset.  This indicates that the simulated galaxy images are different from the real ones and that the classifiers are not able to distinguish fake foreground galaxies from lenses more easily.  This is perhaps not unexpected, but does show that the simulated lenses need to be improved before the raw numbers can be directly used to evaluate the performance of a classifier on real data.


\begin{figure*}
 \includegraphics[width=2\columnwidth]{figures/einstein_space.pdf}
 \caption{The AUROC, TPR$_0$, TPR$_{10}$ and the fraction of lenses in the test sample after discarding the lenses with Einstein radii larger than the number indicated on the x-axis. }
 \label{fig:einstein_space}
\end{figure*}

\begin{figure*}
 \includegraphics[width=2\columnwidth]{figures/einstein_ground.pdf}
 \caption{Same as figure~\ref{fig:einstein_space}, but for space-based entries.}
 \label{fig:einstein_ground}
\end{figure*}

\begin{figure*}
 \includegraphics[width=2\columnwidth]{figures/flux_space.pdf}
 \caption{Same as figure~\ref{fig:einstein_space}, but here the x-axis is the flux within the pixels that are above 1 $\sigma$ in the lensed source only image.}
 \label{fig:flux_space}
\end{figure*}

\begin{figure*}
 \includegraphics[width=2\columnwidth]{figures/flux_ground.pdf}
 \caption{Same as figure~\ref{fig:flux_space}, but for space-based entries.}
 \label{fig:flux_ground}
\end{figure*}

\begin{figure*}
\includegraphics[width=2\columnwidth]{figures/npixel_space.pdf}
 \caption{Same as figure~\ref{fig:einstein_space}, but here the x-axis is the number of pixels that are above 1 $\sigma$ in the lensed source only image.  This is an indication of the lensed arcs' size.}
 \label{fig:npixel_space}
\end{figure*}

\begin{figure*}
 \includegraphics[width=2\columnwidth]{figures/npixel_ground.pdf}
 \caption{Same as figure~\ref{fig:npixel_space}, but for space-based entries.}
 \label{fig:npixel_ground}
\end{figure*}

\begin{figure*}
 \includegraphics[width=2\columnwidth]{figures/flux_contrast_space.pdf}
  \caption{Same as figure~\ref{fig:einstein_space}, but here the x-axis is the ratio of the flux coming from the lensed source to the total flux in the image.  (\red{ check this.  Band?})}
 \label{fig:flux_contrast_space}
\end{figure*}

\begin{figure*}
 \includegraphics[width=2\columnwidth]{figures/flux_contrast_ground.pdf}
 \caption{Same as figure~\ref{fig:flux_contrast_space}, but for space-based entries.}
 \label{fig:flux_contrast_ground}
\end{figure*}

Figures~\ref{fig:einstein_space} and \ref{fig:einstein_ground} shows the AUROC, TPR$_0$, TPR$_{10}$ and fraction of lenses as a function of a lower cutoff on the Einstein radius (area).  There is also a vertical dotted line that indicates where no more than 100 lenses in the test sample had Einstein radii larger than this mark.  Beyond this point one should be suspicious of small number statistics.  When deriving the distribution of Einstein radii from data these curves would need to be used to correct for detection bias.  It can be seen the CMU-DeepLens-ResNet, Manchester1, Manchester SVM and GAMOCLASS obtain significantly higher TPR$_0$ and  TPR$_{10}$ for larger Einstein radii.  Manchester1 is the human inspection method.  In some cases these are above 50\% of the lenses that meet the criterion.  Remember that many of the so called lenses are very dim or there is no significant arc because of the source position is well outside the caustic.  If an additional require was placed on the definition of a lens, such as the brightness of the arc being above a threshold, the TPRs would go up.

Figures~\ref{fig:flux_space} and \ref{fig:flux_ground} are the same except that the flux in the lensed image is used as the threshold.  We count only the flux in pixels with flux over one $\sigma$ of the background.  In some cases one can see an abrupt rise in the TPRs at some flux threshold.  CMU-DeepLens-ResNet in particular reaches a TPR$_0$ above 75\% for the brightest $\sim$ 10\% of the lenses.

A lensed image can be bright without being visibly distorted as in the case of a unresolved image.  Figures~\ref{fig:npixel_space} and \ref{fig:npixel_ground} use the number of pixels in the lensed image(s) that are over  one $\sigma$ of the background.  In this case also some classifiers show an abrupt improvement when the image is required to be larger than some threshold.  Interestingly in some cases the TPRs go down with lensed image size after reaching a peak.  This could be because they are not differentiating the arcs from companion galaxies as well in this regime.

Figures~\ref{fig:flux_contrast_space} and \ref{fig:flux_contrast_ground} investigate how the flux contrast between the foreground objects and the lensed source affects the classifiers.  Interestingly some method's TPRs go up with this quantity and some go down.  \red{explanation?}

\red{surface brightness contrast}

\red{breakups Manchester between Neil and Amit}

\section{Conclusions \& discussion}
\label{sec:conclusion}

It is clear that the robustness of lens finders against falsely classifying unusual galaxies as lenses was not adequately tested in this challenge.  Some of the methods which appear overly conservative in this test might be better at avoiding false positives in real data.  This can be seen as a form of over fitting to the test set.
In future challenges we wish to concentrate on this aspect of the problem.

Human inspection was the only method to find the jackpot lens

\section*{Acknowledgements}

EB thanks Raphael Gavazzi for proposing him to participate to the challenge.
AS was supported by World Premier International Research Center Initiative (WPI Initiative), MEXT, Japan.
RBM's research was partly part of project GLENCO, funded under the European Seventh Framework Programme, Ideas, Grant Agreement n. 259349.
AT acknowledges receipt of an STFC postdoctoral research
assistantship.
\red{We thank the International Space Science Institute (ISSI) for hosting and funding our workshop.\footnote{http://www.issibern.ch/}}
CA acknowledges support from the Enrico Fermi
Institute at the University of Chicago, and the University of Chicago
Provost's Office. NL would like to thank the funding support from
NSFC, grant no.11503064, and Shanghai Natural Science Foundation,
grant no. 15ZR1446700. This work was also supported in part by the
Kavli Institute for Cosmological Physics at the University of Chicago
through grant NSF PHY-1125897 and an endowment from the Kavli
Foundation and its founder Fred Kavli.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% REFERENCES %%%%%%%%%%%%%%%%%%

\bibliographystyle{mn2e}
\bibliography{references}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%% APPENDICES %%%%%%%%%%%%%%%%%%%%%

\appendix

\label{lastpage}
\end{document}
